import { pgTable, text, serial, integer, boolean, jsonb, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const models = pgTable("models", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  modelType: text("model_type").notNull(),
  uploadedAt: timestamp("uploaded_at").defaultNow(),
});

export const testCases = pgTable("test_cases", {
  id: serial("id").primaryKey(),
  modelId: integer("model_id").notNull(),
  name: text("name").notNull(),
  inputs: jsonb("inputs").notNull(),
  expectedOutputs: jsonb("expected_outputs").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const testResults = pgTable("test_results", {
  id: serial("id").primaryKey(),
  testCaseId: integer("test_case_id").notNull(),
  status: text("status").notNull(),
  actualOutput: jsonb("actual_output"),
  error: text("error"),
  executedAt: timestamp("executed_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users);
export const insertModelSchema = createInsertSchema(models).omit({ id: true, userId: true, uploadedAt: true });
export const insertTestCaseSchema = createInsertSchema(testCases).omit({ id: true, createdAt: true });

export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Model = typeof models.$inferSelect;
export type InsertModel = z.infer<typeof insertModelSchema>;
export type TestCase = typeof testCases.$inferSelect;
export type InsertTestCase = z.infer<typeof insertTestCaseSchema>;
export type TestResult = typeof testResults.$inferSelect;
import {
  User,
  InsertUser,
  Model,
  InsertModel,
  TestCase,
  InsertTestCase,
  TestResult,
} from "@shared/schema";
import session from "express-session";
import createMemoryStore from "memorystore";

const MemoryStore = createMemoryStore(session);

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Model operations
  createModel(model: InsertModel & { userId: number }): Promise<Model>;
  getModelsByUser(userId: number): Promise<Model[]>;
  getModel(id: number): Promise<Model | undefined>;

  // Test case operations
  createTestCase(testCase: InsertTestCase): Promise<TestCase>;
  getTestCasesByModel(modelId: number): Promise<TestCase[]>;

  // Test results operations
  createTestResult(result: Omit<TestResult, "id">): Promise<TestResult>;
  getTestResultsByTestCase(testCaseId: number): Promise<TestResult[]>;

  sessionStore: session.Store;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private models: Map<number, Model>;
  private testCases: Map<number, TestCase>;
  private testResults: Map<number, TestResult>;
  private currentId: number;
  sessionStore: session.Store;

  constructor() {
    this.users = new Map();
    this.models = new Map();
    this.testCases = new Map();
    this.testResults = new Map();
    this.currentId = 1;
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000,
    });
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.currentId++;
    const user = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }

  async createModel(model: InsertModel & { userId: number }): Promise<Model> {
    const id = this.currentId++;
    const newModel: Model = {
      ...model,
      id,
      description: model.description || null,
      uploadedAt: new Date(),
    };
    this.models.set(id, newModel);
    return newModel;
  }

  async getModelsByUser(userId: number): Promise<Model[]> {
    return Array.from(this.models.values()).filter(
      (model) => model.userId === userId,
    );
  }

  async getModel(id: number): Promise<Model | undefined> {
    return this.models.get(id);
  }

  async createTestCase(testCase: InsertTestCase): Promise<TestCase> {
    const id = this.currentId++;
    const newTestCase = {
      ...testCase,
      id,
      createdAt: new Date(),
    };
    this.testCases.set(id, newTestCase);
    return newTestCase;
  }

  async getTestCasesByModel(modelId: number): Promise<TestCase[]> {
    return Array.from(this.testCases.values()).filter(
      (testCase) => testCase.modelId === modelId,
    );
  }

  async createTestResult(result: Omit<TestResult, "id">): Promise<TestResult> {
    const id = this.currentId++;
    const newResult = { ...result, id };
    this.testResults.set(id, newResult);
    return newResult;
  }

  async getTestResultsByTestCase(testCaseId: number): Promise<TestResult[]> {
    return Array.from(this.testResults.values()).filter(
      (result) => result.testCaseId === testCaseId,
    );
  }
}

export const storage = new MemStorage();
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User as SelectUser } from "@shared/schema";

declare global {
  namespace Express {
    interface User extends SelectUser {}
  }
}

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

export function setupAuth(app: Express) {
  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || "dev_secret_key",
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
    },
  };

  app.set("trust proxy", 1);
  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user || !(await comparePasswords(password, user.password))) {
          return done(null, false);
        }
        return done(null, user);
      } catch (err) {
        return done(err);
      }
    }),
  );

  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (err) {
      done(err);
    }
  });
}
import type { Express } from "express";
import { createServer, type Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
import multer from "multer";
import passport from "passport";
import { insertModelSchema, insertTestCaseSchema } from "@shared/schema";

const upload = multer({ storage: multer.memoryStorage() });

export async function registerRoutes(app: Express): Promise<Server> {
  setupAuth(app);

  // Auth routes
  app.post("/api/register", async (req, res, next) => {
    try {
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        return res.status(400).send("Username already exists");
      }

      const user = await storage.createUser(req.body);
      req.login(user, (err) => {
        if (err) return next(err);
        res.json(user);
      });
    } catch (err) {
      next(err);
    }
  });

  app.post("/api/login", passport.authenticate("local"), (req, res) => {
    res.json(req.user);
  });

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    res.json(req.user);
  });

  // Model routes
  app.post("/api/models", upload.single("model"), async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    if (!req.file) return res.status(400).send("No model file uploaded");

    const modelData = insertModelSchema.parse(req.body);
    const model = await storage.createModel({
      ...modelData,
      userId: req.user.id,
    });
    res.json(model);
  });

  app.get("/api/models", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const models = await storage.getModelsByUser(req.user.id);
    res.json(models);
  });

  // Test case routes
  app.post("/api/test-cases", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const testCaseData = insertTestCaseSchema.parse(req.body);
    const testCase = await storage.createTestCase(testCaseData);
    res.json(testCase);
  });

  app.get("/api/models/:modelId/test-cases", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const modelId = parseInt(req.params.modelId);
    const testCases = await storage.getTestCasesByModel(modelId);
    res.json(testCases);
  });

  // Test results routes
  app.get("/api/test-cases/:testCaseId/results", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const testCaseId = parseInt(req.params.testCaseId);
    const results = await storage.getTestResultsByTestCase(testCaseId);
    res.json(results);
  });

  const httpServer = createServer(app);
  return httpServer;
}import { createContext, ReactNode, useContext } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { insertUserSchema, User as SelectUser, InsertUser } from "@shared/schema";
import { getQueryFn, apiRequest, queryClient } from "../lib/queryClient";
import { useToast } from "@/hooks/use-toast";

type AuthContextType = {
  user: SelectUser | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<SelectUser, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<SelectUser, Error, InsertUser>;
};

type LoginData = Pick<InsertUser, "username" | "password">;

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<SelectUser | null, Error>({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" }),
  });

  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      const res = await apiRequest("POST", "/api/login", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Welcome back!",
        description: `Logged in as ${user.username}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (credentials: InsertUser) => {
      const res = await apiRequest("POST", "/api/register", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Welcome!",
        description: "Account created successfully",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      toast({
        title: "Logged out",
        description: "See you soon!",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Logout failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route } from "wouter";

export function ProtectedRoute({
  path,
  component: Component,
}: {
  path: string;
  component: () => React.JSX.Element;
}) {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }

  if (!user) {
    return (
      <Route path={path}>
        <Redirect to="/auth" />
      </Route>
    );
  }

  return <Route path={path} component={Component} />;
}
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { AuthProvider } from "./hooks/use-auth";
import { ProtectedRoute } from "./lib/protected-route";
import NotFound from "@/pages/not-found";
import AuthPage from "@/pages/auth-page";
import HomePage from "@/pages/home-page";
import Dashboard from "@/pages/dashboard";

function Router() {
  return (
    <Switch>
      <ProtectedRoute path="/" component={HomePage} />
      <ProtectedRoute path="/dashboard" component={Dashboard} />
      <Route path="/auth" component={AuthPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <Router />
        <Toaster />
      </AuthProvider>
    </QueryClientProvider>
  );
}

export default App;
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useAuth } from "@/hooks/use-auth";
import { insertUserSchema, InsertUser } from "@shared/schema";
import { Redirect } from "wouter";
import { Loader2, Lock, UserCircle2 } from "lucide-react";

export default function AuthPage() {
  const { user, loginMutation, registerMutation } = useAuth();

  const loginForm = useForm<InsertUser>({
    resolver: zodResolver(insertUserSchema),
    defaultValues: {
      username: "",
      password: "",
    },
  });

  const registerForm = useForm<InsertUser>({
    resolver: zodResolver(insertUserSchema),
    defaultValues: {
      username: "",
      password: "",
    },
  });

  if (user) {
    return <Redirect to="/" />;
  }

  return (
    <div className="min-h-screen grid md:grid-cols-2">
      <div className="flex items-center justify-center p-8">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle>Welcome to AI Testing Platform</CardTitle>
          </CardHeader>
          <CardContent>
            <Tabs defaultValue="login">
              <TabsList className="grid w-full grid-cols-2 mb-6">
                <TabsTrigger value="login">Login</TabsTrigger>
                <TabsTrigger value="register">Register</TabsTrigger>
              </TabsList>

              <TabsContent value="login">
                <Form {...loginForm}>
                  <form onSubmit={loginForm.handleSubmit((data) => loginMutation.mutate(data))} className="space-y-4">
                    <FormField
                      control={loginForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={loginForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input type="password" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button type="submit" className="w-full" disabled={loginMutation.isPending}>
                      {loginMutation.isPending ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Lock className="mr-2 h-4 w-4" />
                      )}
                      Login
                    </Button>
                  </form>
                </Form>
              </TabsContent>

              <TabsContent value="register">
                <Form {...registerForm}>
                  <form onSubmit={registerForm.handleSubmit((data) => registerMutation.mutate(data))} className="space-y-4">
                    <FormField
                      control={registerForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input type="password" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button type="submit" className="w-full" disabled={registerMutation.isPending}>
                      {registerMutation.isPending ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : (
                        <UserCircle2 className="mr-2 h-4 w-4" />
                      )}
                      Register
                    </Button>
                  </form>
                </Form>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>

      <div className="hidden md:flex flex-col justify-center p-8 bg-slate-50">
        <div className="max-w-md mx-auto">
          <h1 className="text-4xl font-bold mb-4">AI Testing Platform</h1>
          <p className="text-lg text-gray-600 mb-6">
            Upload your AI models and create comprehensive test suites to validate their performance and reliability.
          </p>
          <ul className="space-y-4">
            <li className="flex items-center gap-2 text-gray-700">
              <span className="w-2 h-2 bg-primary rounded-full" />
              Upload and manage AI models
            </li>
            <li className="flex items-center gap-2 text-gray-700">
              <span className="w-2 h-2 bg-primary rounded-full" />
              Create custom test cases
            </li>
            <li className="flex items-center gap-2 text-gray-700">
              <span className="w-2 h-2 bg-primary rounded-full" />
              Automated test execution
            </li>
            <li className="flex items-center gap-2 text-gray-700">
              <span className="w-2 h-2 bg-primary rounded-full" />
              Detailed performance analytics
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
}
import { useQuery } from "@tanstack/react-query";
import { Model } from "@shared/schema";
import { useAuth } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Link } from "wouter";
import { Plus, BarChart, FileUp, Brain, TestTube, Activity, ArrowUpRight } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";
import { Progress } from "@/components/ui/progress";

export default function HomePage() {
  const { user } = useAuth();

  const { data: models, isLoading } = useQuery<Model[]>({
    queryKey: ["/api/models"],
  });

  // Calculate stats
  const totalModels = models?.length || 0;
  const recentModels = models?.filter(m => {
    const uploadDate = new Date(m.uploadedAt);
    const lastWeek = new Date();
    lastWeek.setDate(lastWeek.getDate() - 7);
    return uploadDate > lastWeek;
  }).length || 0;

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-secondary/10">
      <div className="container mx-auto p-8">
        {/* Hero Section */}
        <div className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-8 mb-12">
          <div>
            <h1 className="text-4xl font-bold mb-4">
              Welcome back, <span className="text-primary">{user?.username}</span>!
            </h1>
            <p className="text-xl text-muted-foreground max-w-xl">
              Manage and test your AI models with comprehensive analytics and automated testing.
            </p>
          </div>
          <Link href="/dashboard">
            <Button size="lg" className="bg-primary/90 hover:bg-primary">
              <Plus className="mr-2 h-5 w-5" />
              Upload New Model
            </Button>
          </Link>
        </div>

        {/* Stats Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-12">
          <Card className="bg-primary/5 border-primary/20">
            <CardHeader>
              <CardTitle className="flex items-center text-lg">
                <Brain className="mr-2 h-5 w-5 text-primary" />
                Total Models
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">{totalModels}</div>
              <p className="text-sm text-muted-foreground">Across all types</p>
            </CardContent>
          </Card>

          <Card className="bg-blue-500/5 border-blue-500/20">
            <CardHeader>
              <CardTitle className="flex items-center text-lg">
                <Activity className="mr-2 h-5 w-5 text-blue-500" />
                Recent Activity
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">{recentModels}</div>
              <p className="text-sm text-muted-foreground">New models this week</p>
            </CardContent>
          </Card>

          <Card className="bg-green-500/5 border-green-500/20">
            <CardHeader>
              <CardTitle className="flex items-center text-lg">
                <TestTube className="mr-2 h-5 w-5 text-green-500" />
                Test Cases
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">--</div>
              <p className="text-sm text-muted-foreground">Total test scenarios</p>
            </CardContent>
          </Card>

          <Card className="bg-purple-500/5 border-purple-500/20">
            <CardHeader>
              <CardTitle className="flex items-center text-lg">
                <BarChart className="mr-2 h-5 w-5 text-purple-500" />
                Success Rate
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">--</div>
              <p className="text-sm text-muted-foreground">Average pass rate</p>
            </CardContent>
          </Card>
        </div>

        {/* Models Grid */}
        <div className="mb-8">
          <h2 className="text-2xl font-semibold mb-6">Your AI Models</h2>
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
            {isLoading ? (
              Array(3).fill(0).map((_, i) => (
                <Card key={i} className="border border-border/50">
                  <CardHeader>
                    <Skeleton className="h-6 w-3/4" />
                  </CardHeader>
                  <CardContent>
                    <Skeleton className="h-4 w-full mb-2" />
                    <Skeleton className="h-4 w-2/3" />
                  </CardContent>
                </Card>
              ))
            ) : models?.length ? (
              models.map((model) => (
                <Card key={model.id} className="group hover:shadow-lg transition-all duration-300 border border-border/50">
                  <CardHeader>
                    <CardTitle className="flex items-center justify-between">
                      <span className="truncate">{model.name}</span>
                      <Link href={`/dashboard?model=${model.id}`}>
                        <Button variant="ghost" size="icon" className="opacity-0 group-hover:opacity-100 transition-opacity">
                          <ArrowUpRight className="h-4 w-4" />
                        </Button>
                      </Link>
                    </CardTitle>
                    <CardDescription>{model.modelType}</CardDescription>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground mb-4 line-clamp-2">
                      {model.description || "No description provided"}
                    </p>
                    <div className="space-y-3">
                      <div className="flex items-center justify-between text-sm">
                        <span className="text-muted-foreground">Test Coverage</span>
                        <span className="font-medium">--</span>
                      </div>
                      <Progress value={33} className="h-1" />
                      <div className="flex items-center text-sm text-muted-foreground">
                        <FileUp className="mr-2 h-4 w-4" />
                        {new Date(model.uploadedAt).toLocaleDateString()}
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            ) : (
              <Card className="col-span-full border border-dashed">
                <CardContent className="flex flex-col items-center justify-center py-12">
                  <Brain className="h-12 w-12 text-muted-foreground mb-4" />
                  <h3 className="text-lg font-medium mb-2">No models yet</h3>
                  <p className="text-center text-muted-foreground mb-4 max-w-md">
                    Get started by uploading your first AI model for testing and analysis.
                  </p>
                  <Link href="/dashboard">
                    <Button>
                      <Plus className="mr-2 h-4 w-4" />
                      Upload First Model
                    </Button>
                  </Link>
                </CardContent>
              </Card>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation, useQuery } from "@tanstack/react-query";
import { insertModelSchema, insertTestCaseSchema, InsertModel, Model, TestCase } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from "@/components/ui/form";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/hooks/use-toast";
import { Separator } from "@/components/ui/separator";
import { ScrollArea } from "@/components/ui/scroll-area";
import { 
  Loader2, Upload, Plus, Brain, FileText, TestTube, 
  ChevronRight, AlertTriangle, CheckCircle, XCircle 
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";

export default function Dashboard() {
  const { toast } = useToast();

  const modelForm = useForm<InsertModel>({
    resolver: zodResolver(insertModelSchema),
    defaultValues: {
      name: "",
      description: "",
      modelType: "",
    },
  });

  const uploadModelMutation = useMutation({
    mutationFn: async (data: InsertModel & { file: File }) => {
      const formData = new FormData();
      formData.append("model", data.file);
      Object.entries(data).forEach(([key, value]) => {
        if (key !== "file" && value != null) {
          formData.append(key, value.toString());
        }
      });

      const res = await fetch("/api/models", {
        method: "POST",
        body: formData,
        credentials: "include",
      });

      if (!res.ok) {
        throw new Error(await res.text());
      }

      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/models"] });
      toast({
        title: "Success",
        description: "Model uploaded successfully",
      });
      modelForm.reset();
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const { data: models } = useQuery<Model[]>({
    queryKey: ["/api/models"],
  });

  const { data: testCases, isLoading: isLoadingTestCases } = useQuery<TestCase[]>({
    queryKey: ["/api/models", models?.[0]?.id, "test-cases"],
    enabled: !!models?.[0]?.id,
  });

  const handleModelSubmit = async (data: InsertModel) => {
    const fileInput = document.querySelector<HTMLInputElement>('input[type="file"]');
    const file = fileInput?.files?.[0];

    if (!file) {
      toast({
        title: "Error",
        description: "Please select a model file to upload",
        variant: "destructive",
      });
      return;
    }

    uploadModelMutation.mutate({ ...data, file } as InsertModel & { file: File });
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-secondary/10">
      <div className="container mx-auto p-8">
        <Tabs defaultValue="upload" className="space-y-8">
          <div className="flex items-center justify-between">
            <TabsList className="grid w-[400px] grid-cols-2">
              <TabsTrigger value="upload" className="data-[state=active]:bg-primary data-[state=active]:text-primary-foreground">
                <Upload className="mr-2 h-4 w-4" />
                Upload Model
              </TabsTrigger>
              <TabsTrigger value="test" className="data-[state=active]:bg-primary data-[state=active]:text-primary-foreground">
                <TestTube className="mr-2 h-4 w-4" />
                Test Cases
              </TabsTrigger>
            </TabsList>
          </div>

          <TabsContent value="upload" className="space-y-8">
            <div className="grid lg:grid-cols-3 gap-8">
              <Card className="lg:col-span-2">
                <CardHeader>
                  <CardTitle>Upload New Model</CardTitle>
                  <CardDescription>
                    Upload your AI model for testing. Supported formats: .h5, .pkl, .pt, .onnx
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <Form {...modelForm}>
                    <form onSubmit={modelForm.handleSubmit(handleModelSubmit)} className="space-y-6">
                      <FormField
                        control={modelForm.control}
                        name="name"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Model Name</FormLabel>
                            <FormControl>
                              <Input {...field} />
                            </FormControl>
                            <FormDescription>
                              Give your model a unique, descriptive name
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={modelForm.control}
                        name="description"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Description</FormLabel>
                            <FormControl>
                              <Textarea {...field} />
                            </FormControl>
                            <FormDescription>
                              Describe your model's purpose and characteristics
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={modelForm.control}
                        name="modelType"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Model Type</FormLabel>
                            <FormControl>
                              <Input {...field} placeholder="e.g., Classification, NLP, Computer Vision" />
                            </FormControl>
                            <FormDescription>
                              Specify the type or category of your AI model
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormItem>
                        <FormLabel>Model File</FormLabel>
                        <FormControl>
                          <Input 
                            type="file" 
                            accept=".h5,.pkl,.pt,.onnx"
                            className="file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-primary/10 file:text-primary hover:file:bg-primary/20" 
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>

                      <Button 
                        type="submit" 
                        disabled={uploadModelMutation.isPending}
                        className="w-full"
                      >
                        {uploadModelMutation.isPending ? (
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        ) : (
                          <Upload className="mr-2 h-4 w-4" />
                        )}
                        Upload Model
                      </Button>
                    </form>
                  </Form>
                </CardContent>
              </Card>

              <div className="space-y-6">
                <Card>
                  <CardHeader>
                    <CardTitle className="text-lg">Upload Guidelines</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <ul className="space-y-4">
                      <li className="flex items-start gap-2 text-sm">
                        <FileText className="h-5 w-5 text-primary shrink-0" />
                        <span>Ensure your model file is in a supported format (.h5, .pkl, .pt, .onnx)</span>
                      </li>
                      <li className="flex items-start gap-2 text-sm">
                        <Brain className="h-5 w-5 text-primary shrink-0" />
                        <span>Choose a descriptive name that reflects the model's purpose</span>
                      </li>
                      <li className="flex items-start gap-2 text-sm">
                        <AlertTriangle className="h-5 w-5 text-primary shrink-0" />
                        <span>Maximum file size: 500MB</span>
                      </li>
                    </ul>
                  </CardContent>
                </Card>

                {models && models.length > 0 && (
                  <Card>
                    <CardHeader>
                      <CardTitle className="text-lg">Recent Uploads</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <ScrollArea className="h-[200px]">
                        <div className="space-y-4">
                          {models.map((model) => (
                            <div
                              key={model.id}
                              className="flex items-center justify-between p-2 rounded-lg hover:bg-secondary/50"
                            >
                              <div className="flex items-center gap-2">
                                <Brain className="h-4 w-4 text-primary" />
                                <span className="font-medium">{model.name}</span>
                              </div>
                              <ChevronRight className="h-4 w-4 text-muted-foreground" />
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </CardContent>
                  </Card>
                )}
              </div>
            </div>
          </TabsContent>

          <TabsContent value="test">
            <div className="grid lg:grid-cols-3 gap-8">
              <Card className="lg:col-span-2">
                <CardHeader className="flex flex-row items-center justify-between">
                  <div>
                    <CardTitle>Test Cases</CardTitle>
                    <CardDescription>Create and manage test cases for your models</CardDescription>
                  </div>
                  <Button>
                    <Plus className="mr-2 h-4 w-4" />
                    New Test Case
                  </Button>
                </CardHeader>
                <CardContent>
                  {isLoadingTestCases ? (
                    <div className="flex items-center justify-center p-8">
                      <Loader2 className="h-8 w-8 animate-spin text-primary" />
                    </div>
                  ) : testCases?.length ? (
                    <div className="space-y-4">
                      {testCases.map((testCase) => (
                        <Card key={testCase.id}>
                          <CardContent className="p-4">
                            <div className="flex items-center justify-between mb-4">
                              <h3 className="font-medium flex items-center gap-2">
                                <TestTube className="h-4 w-4 text-primary" />
                                {testCase.name}
                              </h3>
                              <div className="flex items-center gap-2">
                                <Button variant="outline" size="sm">Edit</Button>
                                <Button variant="outline" size="sm">Run</Button>
                              </div>
                            </div>
                            <div className="bg-secondary/50 rounded-lg p-4">
                              <div className="mb-2 font-medium text-sm">Test Input</div>
                              <pre className="text-sm overflow-x-auto">
                                {JSON.stringify(testCase.inputs, null, 2)}
                              </pre>
                            </div>
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-12">
                      <TestTube className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                      <h3 className="text-lg font-medium mb-2">No Test Cases Yet</h3>
                      <p className="text-muted-foreground mb-4">
                        Create your first test case to start validating your model's performance
                      </p>
                      <Button>
                        <Plus className="mr-2 h-4 w-4" />
                        Create Test Case
                      </Button>
                    </div>
                  )}
                </CardContent>
              </Card>

              <div className="space-y-6">
                <Card>
                  <CardHeader>
                    <CardTitle className="text-lg">Test Results</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-4">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <CheckCircle className="h-4 w-4 text-green-500" />
                          <span className="text-sm">Passed</span>
                        </div>
                        <span className="font-medium">0</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <XCircle className="h-4 w-4 text-red-500" />
                          <span className="text-sm">Failed</span>
                        </div>
                        <span className="font-medium">0</span>
                      </div>
                      <Separator />
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-medium">Total Tests</span>
                        <span className="font-medium">0</span>
                      </div>
                    </div>
                  </CardContent>
                </Card>

                <Card>
                  <CardHeader>
                    <CardTitle className="text-lg">Quick Actions</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-2">
                      <Button variant="outline" className="w-full justify-start">
                        <Plus className="mr-2 h-4 w-4" />
                        New Test Case
                      </Button>
                      <Button variant="outline" className="w-full justify-start">
                        <Upload className="mr-2 h-4 w-4" />
                        Import Tests
                      </Button>
                      <Button variant="outline" className="w-full justify-start">
                        <TestTube className="mr-2 h-4 w-4" />
                        Run All Tests
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}
import { storage } from "./storage";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

export async function loadDemoData() {
  // Create demo user if not exists
  const demoUser = await storage.getUserByUsername("demo");
  if (!demoUser) {
    const user = await storage.createUser({
      username: "demo",
      password: await hashPassword("demo123"),
    });

    // Sample Models
    const models = [
      {
        name: "Sentiment Analysis Model",
        description: "BERT-based model for analyzing text sentiment in product reviews",
        modelType: "NLP",
        userId: user.id,
      },
      {
        name: "Image Classification CNN",
        description: "Convolutional Neural Network for classifying images into 10 categories",
        modelType: "Computer Vision",
        userId: user.id,
      },
      {
        name: "Product Recommender",
        description: "Collaborative filtering model for e-commerce product recommendations",
        modelType: "Recommendation",
        userId: user.id,
      },
    ];

    // Create models
    for (const modelData of models) {
      const model = await storage.createModel(modelData);

      // Add test cases for each model
      const testCases = [
        {
          modelId: model.id,
          name: "Basic Functionality Test",
          inputs: {
            text: "This product is amazing and works perfectly!",
            temperature: 0.7,
          },
          expectedOutputs: {
            sentiment: "positive",
            confidence: 0.95,
          },
        },
        {
          modelId: model.id,
          name: "Edge Case Test",
          inputs: {
            text: "",
            temperature: 0.5,
          },
          expectedOutputs: {
            error: "Input text cannot be empty",
          },
        },
      ];

      for (const testCaseData of testCases) {
        const testCase = await storage.createTestCase(testCaseData);

        // Add some test results
        await storage.createTestResult({
          testCaseId: testCase.id,
          status: "passed",
          actualOutput: testCaseData.expectedOutputs,
          error: null,
          executedAt: new Date(),
        });
      }
    }
  }
}